<!-- build time:Tue Jul 22 2025 11:01:57 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="枯萎的花将在另一彼岸悄然绽放" href="https://yunhdan.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" title="枯萎的花将在另一彼岸悄然绽放" href="https://yunhdan.github.io/atom.xml"><link rel="alternate" type="application/json" title="枯萎的花将在另一彼岸悄然绽放" href="https://yunhdan.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://yunhdan.github.io/cs/ACM%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%95/"><title>ACM算法题单 - 计算机 | Runfar's Zone = 枯萎的花将在另一彼岸悄然绽放</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">ACM算法题单</h1><div class="meta"><span class="item" title="创建时间：2025-02-20 22:22:05"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2025-02-20T22:22:05+08:00">2025-02-20</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>15k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>14 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Runfar's Zone</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://s2.loli.net/2024/12/07/2aWVgHCsR3DbJ6S.png"></li><li class="item" data-background-image="https://s2.loli.net/2025/05/18/QColdBwvmPp8zXT.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/04/CwaK19SUG28Jskz.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/04/eWvx2STbizqcHZl.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2024/12/04/TcIOxZAHaXNbG2o.jpg"></li><li class="item" data-background-image="https://s2.loli.net/2025/05/18/lkhyaSIx7uTZFbs.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/cs/" itemprop="item" rel="index" title="分类于 计算机"><span itemprop="name">计算机</span></a><meta itemprop="position" content="1"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://yunhdan.github.io/cs/ACM%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%95/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/me.jpg"><meta itemprop="name" content="Runhua Deng"><meta itemprop="description" content=", 计算机视觉 & 图像恢复"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="枯萎的花将在另一彼岸悄然绽放"></span><div class="body md" itemprop="articleBody"><p>:::info</p><p>目的：为了备战蓝桥杯（4月12日）和夏令营预推免的机试。</p><p>每一题目标：彻底弄懂该题思路。</p><p>:::</p><h1 id="哈希表-blue"><a href="#哈希表-blue" class="headerlink" title="[哈希表]{.blue}"></a>[哈希表]{.blue}</h1><p><strong>简单</strong>：</p><p><code>LeetCode——</code>罗马数字转整数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yb21hbi10by1pbnRlZ2VyLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9aGFzaC10YWJsZQ==">https://leetcode.cn/problems/roman-to-integer/?envType=problem-list-v2&amp;envId=hash-table</span></p><p><code>LeetCode——</code>多数元素：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYWpvcml0eS1lbGVtZW50Lz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9aGFzaC10YWJsZQ==">https://leetcode.cn/problems/majority-element/?envType=problem-list-v2&amp;envId=hash-table</span></p><p><code>LeetCode——</code>两数之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtL2Rlc2NyaXB0aW9uLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9aGFzaC10YWJsZQ==">1. 两数之和 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>环形链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9saW5rZWQtbGlzdC1jeWNsZS8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPWhhc2gtdGFibGU=">141. 环形链表 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>相交链表：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnRlcnNlY3Rpb24tb2YtdHdvLWxpbmtlZC1saXN0cy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPWhhc2gtdGFibGU=">160. 相交链表 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>快乐数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9oYXBweS1udW1iZXIvZGVzY3JpcHRpb24v">202. 快乐数 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>同构字符串：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pc29tb3JwaGljLXN0cmluZ3MvZGVzY3JpcHRpb24v">205. 同构字符串 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>存在重复元素：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWlucy1kdXBsaWNhdGUvZGVzY3JpcHRpb24v">217. 存在重复元素 - 力扣（LeetCode）</span></p><p><strong>中等</strong>：</p><p><code>LeetCode——</code>字母异位词分组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ncm91cC1hbmFncmFtcy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1zdHVkeS1wbGFuLXYyJmFtcDtlbnZJZD10b3AtMTAwLWxpa2Vk">49. 字母异位词分组 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>最长连续序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWNvbnNlY3V0aXZlLXNlcXVlbmNlLz9lbnZUeXBlPXN0dWR5LXBsYW4tdjImYW1wO2VudklkPXRvcC0xMDAtbGlrZWQ=">128. 最长连续序列 - 力扣（LeetCode）</span>:fire:</p><h1 id="双指针-blue"><a href="#双指针-blue" class="headerlink" title="[双指针]{.blue}"></a>[双指针]{.blue}</h1><p>[相向双指针]{.rainbow}：</p><p><code>LeetCode——</code>反转字符串（优化相向指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXN0cmluZy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXR3by1wb2ludGVycw==">https://leetcode.cn/problems/reverse-string/description/?envType=problem-list-v2&amp;envId=two-pointers</span></p><p><code>LeetCode——</code>验证回文串（相向指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYWxpbmRyb21lLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9dHdvLXBvaW50ZXJz">125. 验证回文串 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>回文链表（相向指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYWxpbmRyb21lLWxpbmtlZC1saXN0L2Rlc2NyaXB0aW9uLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9dHdvLXBvaW50ZXJz">234. 回文链表 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>盛最多水的容器（暴力必超时，相向指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWluZXItd2l0aC1tb3N0LXdhdGVyLz9lbnZUeXBlPXN0dWR5LXBsYW4tdjImYW1wO2VudklkPXRvcC0xMDAtbGlrZWQ=">11. 盛最多水的容器 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>三数之和（枚举与相向指针的结合）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy8zc3VtLz9lbnZUeXBlPXN0dWR5LXBsYW4tdjImYW1wO2VudklkPXRvcC0xMDAtbGlrZWQ=">15. 三数之和 - 力扣（LeetCode）</span>:fire:</p><p>[原地修改]{.rainbow}：</p><p><code>LeetCode——</code>移动零（快慢指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tb3ZlLXplcm9lcy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1zdHVkeS1wbGFuLXYyJmFtcDtlbnZJZD10b3AtMTAwLWxpa2Vk">283. 移动零 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>删除有序数组中的重复项：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZHVwbGljYXRlcy1mcm9tLXNvcnRlZC1hcnJheS9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXR3by1wb2ludGVycw==">26. 删除有序数组中的重复项 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>移除元素：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmUtZWxlbWVudC9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXR3by1wb2ludGVycw==">27. 移除元素 - 力扣（LeetCode）</span></p><p>[其他]{.rainbow}：</p><p><code>LeetCode——</code>找出字符串中第一个匹配项的下标：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1pbmRleC1vZi10aGUtZmlyc3Qtb2NjdXJyZW5jZS1pbi1hLXN0cmluZy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXR3by1wb2ludGVycw==">28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>合并两个有序数组（三指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS1zb3J0ZWQtYXJyYXkvP2VudlR5cGU9cHJvYmxlbS1saXN0LXYyJmFtcDtlbnZJZD10d28tcG9pbnRlcnM=">https://leetcode.cn/problems/merge-sorted-array/?envType=problem-list-v2&amp;envId=two-pointers</span> :fire:</p><p><code>LeetCode——</code>反转字符串中的元音字母（双向指针）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXZlcnNlLXZvd2Vscy1vZi1hLXN0cmluZy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXR3by1wb2ludGVycw==">345. 反转字符串中的元音字母 - 力扣（LeetCode）</span></p><h1 id="滑动窗口-blue"><a href="#滑动窗口-blue" class="headerlink" title="[滑动窗口]{.blue}"></a>[滑动窗口]{.blue}</h1><p><strong>简单</strong>：</p><p><code>LeetCode——</code>存在重复元素<code>II</code>（暴力必超时，定长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250YWlucy1kdXBsaWNhdGUtaWkvZGVzY3JpcHRpb24vP2VudlR5cGU9cHJvYmxlbS1saXN0LXYyJmFtcDtlbnZJZD1zbGlkaW5nLXdpbmRvdw==">219. 存在重复元素 II - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>最长和谐子序列（变长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LWhhcm1vbmlvdXMtc3Vic2VxdWVuY2UvZGVzY3JpcHRpb24vP2VudlR5cGU9cHJvYmxlbS1saXN0LXYyJmFtcDtlbnZJZD1zbGlkaW5nLXdpbmRvdw==">594. 最长和谐子序列 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>子数组最大平均数<code>I</code>（定长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWF2ZXJhZ2Utc3ViYXJyYXktaS9kZXNjcmlwdGlvbi8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXNsaWRpbmctd2luZG93">643. 子数组最大平均数 I - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>拆炸弹（定长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWZ1c2UtdGhlLWJvbWIvZGVzY3JpcHRpb24vP2VudlR5cGU9cHJvYmxlbS1saXN0LXYyJmFtcDtlbnZJZD1zbGlkaW5nLXdpbmRvdw==">1652. 拆炸弹 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>找到一个数字的<code>K</code>美丽值（定长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1rLWJlYXV0eS1vZi1hLW51bWJlci8/ZW52VHlwZT1wcm9ibGVtLWxpc3QtdjImYW1wO2VudklkPXNsaWRpbmctd2luZG93">2269. 找到一个数字的 K 美丽值 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>每个字符最多出现两次的最长子字符串（变长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWxlbmd0aC1zdWJzdHJpbmctd2l0aC10d28tb2NjdXJyZW5jZXMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/maximum-length-substring-with-two-occurrences/description/</span></p><p><strong>中等</strong>：</p><p><code>LeetCode——</code>定长子串中元音的最大数目（最佳定长滑窗入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLW51bWJlci1vZi12b3dlbHMtaW4tYS1zdWJzdHJpbmctb2YtZ2l2ZW4tbGVuZ3RoL2Rlc2NyaXB0aW9uLw==">1456. 定长子串中元音的最大数目 - 力扣（LeetCode）</span></p><p>+++info Summary<br>定长滑窗模板：<br>入——更新——出</p><ul><li>[入]{.blue}：下标为 i 的元素进入窗口，更新相关统计量。如果 i&lt;k−1 则重复第一步，目的是为了让窗口全部进入。窗口全部进入后，循环下标值i==k-1，开始做更新的内容。</li><li>[更新]{.blue}：更新答案。一般是更新最大值/最小值。</li><li>[出]{.blue}：下标为 i−k+1 的尾部元素离开窗口，更新相关统计量。<pre><code class="lang-python">class Solution:
  def maxVowels(self, s: str, k: int) -&gt; int:
      ans = vowel = 0
      for i, c in enumerate(s):
          # 1. 进入窗口
          if c in &quot;aeiou&quot;:
              vowel += 1
          if i &lt; k - 1:  # 窗口大小不足 k
              continue
          # 2. 更新答案
          ans = max(ans, vowel)
          # 3. 离开窗口
          if s[i - k + 1] in &quot;aeiou&quot;:
              vowel -= 1
      return ans
</code></pre>+++</li></ul><p><code>LeetCode——</code>无重复字符的最长子串（变长滑窗入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YnN0cmluZy13aXRob3V0LXJlcGVhdGluZy1jaGFyYWN0ZXJzL2Rlc2NyaXB0aW9uLz9lbnZUeXBlPXN0dWR5LXBsYW4tdjImYW1wO2VudklkPXRvcC0xMDAtbGlrZWQ=">3. 无重复字符的最长子串 - 力扣（LeetCode）</span></p><p>+++info Summary<br>变长滑窗的核心思想是：维护一个有条件的滑动窗口。滑窗右端点右移的目的是为了扩大窗口，破坏条件。滑窗左侧端点左移的目的是为了维护这个条件，直至条件成立。下面是与哈希集合结合的滑窗去重模板（学习自灵茶山艾府）：</p><pre><code class="lang-python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        table = set()
        left = maxValue = 0
        for right, c in enumerate(s):
            while c in table:
                table.remove(s[left])
                left += 1
            table.add(c)
            maxValue = max(maxValue, right - left + 1)
        return maxValue
</code></pre><p>变长滑窗需要额外的一个指针或者一个别的手段记录滑窗尾部位置。<br>+++</p><p><code>LeetCode——</code>重复的<code>DNA</code>序列：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZXBlYXRlZC1kbmEtc2VxdWVuY2VzL2Rlc2NyaXB0aW9uLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9c2xpZGluZy13aW5kb3c=">187. 重复的DNA序列 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>长度最小的数组（变长滑窗）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXNpemUtc3ViYXJyYXktc3VtLz9lbnZUeXBlPXByb2JsZW0tbGlzdC12MiZhbXA7ZW52SWQ9c2xpZGluZy13aW5kb3c=">209. 长度最小的子数组 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>大小为<code>K</code>且平均值大于等于阈值的子数组数目（定长滑窗练手题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2Ytc3ViLWFycmF5cy1vZi1zaXplLWstYW5kLWF2ZXJhZ2UtZ3JlYXRlci10aGFuLW9yLWVxdWFsLXRvLXRocmVzaG9sZC9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/</span></p><p><code>LeetCode——</code>半径为<code>K</code>的子数组平均值（定长滑窗检验入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9rLXJhZGl1cy1zdWJhcnJheS1hdmVyYWdlcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/k-radius-subarray-averages/description/</span></p><p><code>LeetCode——</code>删掉一个元素以后全为1的最长子数组（考验变长滑窗维护条件的选择）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sb25nZXN0LXN1YmFycmF5LW9mLTFzLWFmdGVyLWRlbGV0aW5nLW9uZS1lbGVtZW50L2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/</span> :fire:</p><h1 id="二分算法-blue"><a href="#二分算法-blue" class="headerlink" title="[二分算法]{.blue}"></a>[二分算法]{.blue}</h1><p>[二分查找]{.rainbow}：</p><p><code>LeetCode——</code>搜索插入位置（闭区间二分查找）<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW5zZXJ0LXBvc2l0aW9uL2Rlc2NyaXB0aW9uLw==">35. 搜索插入位置 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>二分查找：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc2VhcmNoL2Rlc2NyaXB0aW9uLw==">704. 二分查找 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>寻找比目标字母大的最小字母（左闭右开区间二分查找）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXNtYWxsZXN0LWxldHRlci1ncmVhdGVyLXRoYW4tdGFyZ2V0L2Rlc2NyaXB0aW9uLw==">744. 寻找比目标字母大的最小字母 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>正整数和负整数的最大计数（重用二分查找）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWNvdW50LW9mLXBvc2l0aXZlLWludGVnZXItYW5kLW5lZ2F0aXZlLWludGVnZXIvZGVzY3JpcHRpb24v">2529. 正整数和负整数的最大计数 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>两个数组间的距离值（二分查找）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1kaXN0YW5jZS12YWx1ZS1iZXR3ZWVuLXR3by1hcnJheXMvZGVzY3JpcHRpb24v">1385. 两个数组间的距离值 - 力扣（LeetCode）</span> :fire:</p><p><code>LeetCode——</code>在排序数组中查找元素的第一个和最后一个位置（二分查找入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWZpcnN0LWFuZC1sYXN0LXBvc2l0aW9uLW9mLWVsZW1lbnQtaW4tc29ydGVkLWFycmF5L2Rlc2NyaXB0aW9uLw==">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</span></p><p>+++info Summary<br>（学习自灵茶山艾府）</p><ul><li>闭区间二分查找模板：<pre><code class="lang-python">class Solution:
  # lower_bound 返回最小的满足 nums[i] &gt;= target 的下标 i
  # 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)
  # 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]
  def lower_bound(self, nums: List[int], target: int) -&gt; int:
      left, right = 0, len(nums) - 1  # 闭区间 [left, right]
      while left &lt;= right:  # 区间不为空
          # 循环不变量：
          # nums[left-1] &lt; target
          # nums[right+1] &gt;= target
          mid = (left + right) // 2
          if nums[mid] &gt;= target:
              right = mid - 1  # 范围缩小到 [left, mid-1]
          else:
              left = mid + 1  # 范围缩小到 [mid+1, right]
      # 循环结束后 left = right+1
      # 此时 nums[left-1] &lt; target 而 nums[left] = nums[right+1] &gt;= target
      # 所以 left 就是第一个 &gt;= target 的元素下标
      return left
</code></pre></li><li>开区间二分查找模板：<pre><code class="lang-python">class Solution:
  # lower_bound 返回最小的满足 nums[i] &gt;= target 的下标 i
  # 如果数组为空，或者所有数都 &lt; target，则返回 len(nums)
  # 要求 nums 是非递减的，即 nums[i] &lt;= nums[i + 1]
  def lower_bound(self, nums: List[int], target: int) -&gt; int:
      left, right = -1, len(nums)  # 开区间 (left, right)
      while left + 1 &lt; right:  # 区间不为空
          mid = (left + right) // 2
          # 循环不变量：
          # nums[left] &lt; target
          # nums[right] &gt;= target
          if nums[mid] &gt;= target:
              right = mid  # 范围缩小到 (left, mid)
          else:
              left = mid  # 范围缩小到 (mid, right)
      # 循环结束后 left+1 = right
      # 此时 nums[left] &lt; target 而 nums[right] &gt;= target
      # 所以 right 就是第一个 &gt;= target 的元素下标
      return right
</code></pre>+++</li></ul><p><code>LeetCode——</code>咒语和药水的成功对数（二分查找）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWNjZXNzZnVsLXBhaXJzLW9mLXNwZWxscy1hbmQtcG90aW9ucy9kZXNjcmlwdGlvbi8=">2300. 咒语和药水的成功对数 - 力扣（LeetCode）</span></p><p>[二分答案]{.rainbow}：</p><p><code>LeetCode——</code>使结果不超过阈值的最小除数（二分答案求最小入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLXRoZS1zbWFsbGVzdC1kaXZpc29yLWdpdmVuLWEtdGhyZXNob2xkLw==">https://leetcode.cn/problems/find-the-smallest-divisor-given-a-threshold/</span> :fire:</p><p>+++info Summary<br>（学习自灵茶山艾府）</p><ul><li>当a和b都是正整数时，向上取整可以转换为向下取整，公式如下：<script type="math/tex;mode=display">\lceil \frac{a}{b} \rceil = \lfloor \frac{a+b-1}{b} \rfloor  = \lfloor \frac{a-1}{b} \rfloor + 1</script></li><li>只要某个数满足的表达式是单调的，我们就能对这个数进行二分查找。</li><li>因为python的ceil向上取整函数计算出的是浮点数，会有精度误差，因此尽可能转换为向下取整函数floor。<br>+++</li></ul><p><code>LeetCode——</code>完成旅途的最少时间（二分答案）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXRpbWUtdG8tY29tcGxldGUtdHJpcHMv">https://leetcode.cn/problems/minimum-time-to-complete-trips/</span> :fire:</p><h1 id="栈-blue"><a href="#栈-blue" class="headerlink" title="[栈]{.blue}"></a>[栈]{.blue}</h1><p>[基础]{.rainbow}：</p><p><code>LeetCode——</code>比较含退格的字符串（模拟栈）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWNrc3BhY2Utc3RyaW5nLWNvbXBhcmUvZGVzY3JpcHRpb24v">844. 比较含退格的字符串 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>棒球比赛（模拟栈）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYXNlYmFsbC1nYW1lL3NvbHV0aW9ucy8=">682. 棒球比赛 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>用栈操作构建数组（无脑题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9idWlsZC1hbi1hcnJheS13aXRoLXN0YWNrLW9wZXJhdGlvbnMvZGVzY3JpcHRpb24v">1441. 用栈操作构建数组 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>从字符串中移除星号（秒杀题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZW1vdmluZy1zdGFycy1mcm9tLWEtc3RyaW5nLw==">https://leetcode.cn/problems/removing-stars-from-a-string/</span></p><p><code>LeetCode——</code>设计浏览器历史记录（用于检验入门的题）（指针与栈结合）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZXNpZ24tYnJvd3Nlci1oaXN0b3J5Lw==">1472. 设计浏览器历史记录 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>验证栈序列（双指针与栈结合）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZGF0ZS1zdGFjay1zZXF1ZW5jZXMvZGVzY3JpcHRpb24v">946. 验证栈序列 - 力扣（LeetCode）</span></p><p><code>LeetCode——</code>有效的括号：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy92YWxpZC1wYXJlbnRoZXNlcy9kZXNjcmlwdGlvbi8/ZW52VHlwZT1zdHVkeS1wbGFuLXYyJmFtcDtlbnZJZD10b3AtMTAwLWxpa2Vk">20. 有效的括号 - 力扣（LeetCode）</span> :fire:</p><p><code>LeetCode——</code>计算字符串的镜像分数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLW1pcnJvci1zY29yZS1vZi1hLXN0cmluZy8=">3412. 计算字符串的镜像分数 - 力扣（LeetCode）</span>:fire:</p><p><code>LeetCode——</code>简化路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zaW1wbGlmeS1wYXRoLw==">https://leetcode.cn/problems/simplify-path/</span> :fire:</p><h1 id="枚举-blue"><a href="#枚举-blue" class="headerlink" title="[枚举]{.blue}"></a>[枚举]{.blue}</h1><p>:::warning<br>同一道题目也会反复出现，比如下面的两数之和出现于前面的哈希表。<br>:::</p><p><code>LeetCode——</code>两数之和（枚举右，维护左+哈希表）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy90d28tc3VtL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/two-sum/description/</span></p><p>+++info Summary<br>（学习自灵茶山艾府）<br>枚举右，维护左<br>双变量问题如：$x+y==target$或者$x-y==target$。可以枚举右边的y，找是否有$x==target-y$满足。通常与哈希表结合。<br>+++</p><p><code>LeetCode——</code>好数对的数目（枚举右，维护左+哈希表）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtZ29vZC1wYWlycy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/number-of-good-pairs/description/</span></p><p><code>LeetCode——</code>可互换矩形的组数（枚举右，维护左+哈希表）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtcGFpcnMtb2YtaW50ZXJjaGFuZ2VhYmxlLXJlY3RhbmdsZXMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/number-of-pairs-of-interchangeable-rectangles/description/</span></p><h1 id="前缀和-blue"><a href="#前缀和-blue" class="headerlink" title="[前缀和]{.blue}"></a>[前缀和]{.blue}</h1><p>[基础]{.rainbow}：<br><code>LeetCode——</code>区域和检索——数组不可变（前缀和入门模板题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yYW5nZS1zdW0tcXVlcnktaW1tdXRhYmxlLw==">https://leetcode.cn/problems/range-sum-query-immutable/</span></p><p>+++info Summary<br>前缀和我在一篇博文有详细介绍原理，于是不再总结。<br>这里注意到Python有一个accumulate函数，这个函数可以计算一个数组对应的前缀和数组。有一个initial参数，将其设为0，相当于在前缀和数组前增加一个0项：</p><pre><code class="lang-python">from itertools import accumulate

# 创建一个列表
data = [1, 2, 3, 4, 5]

# 使用accumulate计算前缀和
result1 = list(accumulate(data))
result2 = list(accumulate(data, initial=0))

# 输出结果
print(result1) # 输出：[1, 3, 6, 10, 15]
print(result2) # 输出：[0, 1, 3, 6, 10, 15]
</code></pre><p>+++</p><p><code>LeetCode——</code>变长子数组求和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtdmFyaWFibGUtbGVuZ3RoLXN1YmFycmF5cy8=">https://leetcode.cn/problems/sum-of-variable-length-subarrays/</span></p><p><code>LeetCode——</code>统计范围内的元音字符串数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC12b3dlbC1zdHJpbmdzLWluLXJhbmdlcy8=">https://leetcode.cn/problems/count-vowel-strings-in-ranges/</span></p><p><code>LeetCode——</code>特殊数组II（数组奇偶性与前缀和）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zcGVjaWFsLWFycmF5LWlpLw==">https://leetcode.cn/problems/special-array-ii/</span> :fire:</p><p>[前缀和与哈希表]{.rainbow}：<br>+++info Summary<br>前缀和两次遍历示例写法：</p><pre><code class="lang-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        s = [0] * (len(nums) + 1)
        for i, x in enumerate(nums):
            s[i + 1] = s[i] + x

        ans = 0
        cnt = defaultdict(int)
        for sj in s:
            ans += cnt[sj - k]
            cnt[sj] += 1
        return ans
</code></pre><p>一遍遍历示例写法（由于遍历nums会从s[1]开始计算，所以要单独处理 s[0]=0）：</p><pre><code class="lang-python">class Solution:
    def subarraySum(self, nums: List[int], k: int) -&gt; int:
        ans = s = 0
        cnt = defaultdict(int)
        cnt[0] = 1  # s[0]=0 单独统计
        for x in nums:
            s += x
            ans += cnt[s - k]
            cnt[s] += 1
        return ans
</code></pre><p>+++</p><p><code>LeetCode——</code>和为K的子数组（启蒙题，值得反复品味）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW0tZXF1YWxzLWsvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/subarray-sum-equals-k/description/</span></p><p><code>LeetCode——</code>和相同的二元子数组：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktc3ViYXJyYXlzLXdpdGgtc3VtL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/binary-subarrays-with-sum/description/</span></p><p><code>LeetCode——</code>和为奇数的子数组数目（区间奇偶与前缀和）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2Ytc3ViLWFycmF5cy13aXRoLW9kZC1zdW0v">https://leetcode.cn/problems/number-of-sub-arrays-with-odd-sum/</span> :fire:</p><p>+++info Summary<br>前缀和奇偶性与数组区间和的关系：<br>如果两个前缀和的奇偶性不同（一个是偶数，一个是奇数），它们之间的子数组和一定是奇数。<br>+++</p><p><code>LeetCode——</code>和可被K整除的子数组（余数哈希+前缀和）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdWJhcnJheS1zdW1zLWRpdmlzaWJsZS1ieS1rLw==">https://leetcode.cn/problems/subarray-sums-divisible-by-k/</span></p><p><code>LeetCode——</code>连续的子数组和（在前一道题基础上加入区间要求）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250aW51b3VzLXN1YmFycmF5LXN1bS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/continuous-subarray-sum/description/</span></p><p><code>LeetCode——</code>连续数组（将不定和转为定和）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb250aWd1b3VzLWFycmF5L2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/contiguous-array/description/</span> :fire:</p><p>+++info Summary<br>本题可以用纯数学的方式避免用if-else判断数组值：<br>令前缀和为prev，nums[i]是数组值，如果要实现遇到nums[i]为1则prev+=1，而遇到nums[i]为-1则prev-=1，用：</p><pre><code class="lang-python">prev += nums[i] * 2 - 1
</code></pre><p>替代：</p><pre><code class="lang-python">if nums[i] == 1:
    prev += 1
else:
    prev -= 1
</code></pre><p>为什么会得到这个公式？我们重新思考一下，其实无外乎可以抽象为：prev += f(nums[i])，这样就能避免用if-else。那么这个函数f如何得到呢？这时候就要考虑nums[i]的值和目标f(nums[i])的值。发现nums[i]和f(nums[i])都可以分别抽象为一个向量，然后就变成了：</p><script type="math/tex;mode=display">f(
\left[
\begin{matrix}
0    \\
1    \\
\end{matrix}
\right]) = 
\left[
\begin{matrix}
-1    \\
1    \\
\end{matrix}
\right]</script><p>一般f是一个线性变换，可以认为<script type="math/tex">f=wx+b</script>，根据线性代数的知识，f也是一个向量，那么就有：</p><script type="math/tex;mode=display">\left[
\begin{matrix}
0    \\
1    \\
\end{matrix}
\right] \left[
\begin{matrix}
a    \\
b    \\
\end{matrix}
\right] = 
\left[
\begin{matrix}
-1    \\
1    \\
\end{matrix}
\right]</script><p>利用矩阵乘法，能够知道a=2，b=-1，即f=2x-1。<br>+++</p><p><code>LeetCode——</code>统计美丽子数组数目：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC10aGUtbnVtYmVyLW9mLWJlYXV0aWZ1bC1zdWJhcnJheXMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/count-the-number-of-beautiful-subarrays/description/</span> :fire:</p><p>[距离和]{.rainbow}</p><p><code>LeetCode——</code>有序数组中差绝对值之和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tb2YtYWJzb2x1dGUtZGlmZmVyZW5jZXMtaW4tYS1zb3J0ZWQtYXJyYXkv">https://leetcode.cn/problems/sum-of-absolute-differences-in-a-sorted-array/</span> :fire:</p><p>[前缀异或和]{.rainbow}</p><p><code>LeetCode——</code>构建回文串检测：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jYW4tbWFrZS1wYWxpbmRyb21lLWZyb20tc3Vic3RyaW5nLw==">https://leetcode.cn/problems/can-make-palindrome-from-substring/</span> :fire:</p><h1 id="网格图-blue"><a href="#网格图-blue" class="headerlink" title="[网格图]{.blue}"></a>[网格图]{.blue}</h1><p>[深度优先搜索DFS]{.rainbow}：<br><code>LeetCode——</code>岛屿数量（入门题，水平垂直方向）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9udW1iZXItb2YtaXNsYW5kcy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/number-of-islands/description/</span></p><p><code>LeetCode——</code>岛屿的最大面积：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXgtYXJlYS1vZi1pc2xhbmQvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/max-area-of-island/description/</span></p><p><code>LeetCode——</code>水域大小（加入对角线方向）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wb25kLXNpemVzLWxjY2kvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/pond-sizes-lcci/description/</span></p><p><code>LeetCode——</code>主题空间（边界不合法情况）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9ZZXNkUHcvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/YesdPw/description/</span> :fire:</p><p><code>LeetCode——</code>岛屿的周长：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pc2xhbmQtcGVyaW1ldGVyL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/island-perimeter/description/</span></p><h1 id="二叉树-blue"><a href="#二叉树-blue" class="headerlink" title="[二叉树]{.blue}"></a>[二叉树]{.blue}</h1><p>[遍历二叉树]{.rainbow}：<br><code>LeetCode——</code>二叉树的前序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcmVvcmRlci10cmF2ZXJzYWwv">https://leetcode.cn/problems/binary-tree-preorder-traversal/</span></p><p>+++info Summary<br>二叉树遍历的递归方式：</p><pre><code class="lang-python"># 假设二叉树类定义如：
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

# 前序遍历
def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    ans = []
    def dfs(root):
        nonlocal ans
        if not root:
            return
        ans.append(root.val)
        dfs(root.left)
        dfs(root.right)
    dfs(root)
    return ans

# 中序遍历
def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    ans = []
    def dfs(root):
        nonlocal ans
        if not root:
            return
        dfs(root.left)
        ans.append(root.val)    # 只变化了这行代码的位置
        dfs(root.right)
    dfs(root)
    return ans

# 后序遍历
def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    ans = []
    def dfs(root):
        nonlocal ans
        if not root:
            return
        dfs(root.left)
        dfs(root.right)
        ans.append(root.val)    # 只变化了这行代码的位置
    dfs(root)
    return ans
</code></pre><p>下面看借用栈实现迭代方式的二叉树前序遍历，学习自腐烂的橘子：<br><img data-src="../../assets/bindtree1.gif" alt="image"><br>整体思路是：</p><ul><li>初始化栈，将根节点入栈</li><li>当栈不为空时，弹出栈顶元素</li><li>如果栈顶元素右子树不为空，那么将右子树压入栈中</li><li>如果栈顶元素左子树不为空，那么将左子树压入栈中<br>前序遍历的迭代方式代码为：<pre><code class="lang-python">def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
  if not root:
      return []
  stack, ans = [root], []
  while stack:
      node = stack.pop()
      if node:
          ans.append(node.val)
          if node.right:
              stack.append(node.right)
          if node.left:
              stack.append(node.left)
  return ans
</code></pre>为什么弹出栈顶节点后，先将右子树压入栈中？因为这是前序遍历，而且栈是先入后出，如果我们想要做到遍历“根-&gt;左子树-&gt;右子树”，那么就要先把右子树压入栈中，再压入左子树。这样后入的左子树就能先被弹出遍历。</li></ul><p>这是一种方便理解的思路，当然还有一种模板式的迭代前序遍历思路，也学习自腐烂的橘子：</p><ul><li>先将根节点cur和所有的左子树压入栈并加入结果中，直至cur为空。</li><li>然后每弹出一个栈顶元素tmp，就到达它的右子树，再将这个节点当作cur，继续按照前面的步骤再来一遍，直至栈为空。</li><li>代码如下：</li></ul><p><img data-src="../../assets/bindtree2.jpg" alt="image"></p><pre><code class="lang-python">def preorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    if not root:
        return []
    cur, stack, ans = root, [], []
    while cur or stack:
        while cur:
            ans.append(cur.val)
            stack.append(cur)
            cur = cur.left
        tmp = stack.pop()
        cur = tmp.right
    return ans
</code></pre><p>这样，首先确保根节点和左子树首先进入栈中，此时遍历到树底部，然后再一一从栈中取出节点，并到达右子树继续遍历。<br>+++</p><p><code>LeetCode——</code>二叉树的中序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1pbm9yZGVyLXRyYXZlcnNhbC9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/binary-tree-inorder-traversal/description/</span></p><p>+++info Summary<br>二叉树的迭代版本中序遍历：</p><pre><code class="lang-python">def inorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    if not root:
        return []
    cur, stack, ans = root, [], []
    while cur or stack:
        while cur:
            stack.append(cur)
            cur = cur.left
        tmp = stack.pop()
        ans.append(tmp.val)    # 同样只移动了这行代码
        cur = tmp.right
    return ans
</code></pre><p>当内层while循环结束时，说明遍历到了二叉树最底层。<br>+++</p><p><code>LeetCode——</code>二叉树的后序遍历：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wb3N0b3JkZXItdHJhdmVyc2FsL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/binary-tree-postorder-traversal/description/</span></p><p>+++info Summary<br>二叉树的“后序遍历”，本质上是二叉树“从右侧开始的前序遍历”。<br>你可以尝试对一个二叉树进行前序遍历，然后反向所得到的列表结果，就是二叉树的后序遍历。按照这个思路，则有该代码：</p><pre><code class="lang-python">def postorderTraversal(self, root: Optional[TreeNode]) -&gt; List[int]:
    if not root:
        return []
    cur, stack, ans = root, [], []
    while cur or stack:
        while cur:
            ans.append(cur.val)
            stack.append(cur)
            cur = cur.right
        tmp = stack.pop()
        cur = tmp.left
    return ans[::-1]
</code></pre><p>+++</p><p><code>LeetCode——</code>叶子相似的树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZWFmLXNpbWlsYXItdHJlZXMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/leaf-similar-trees/description/</span> :fire:</p><p>[自顶向下DFS]{.rainbow}：</p><p>+++info Summary<br>自顶向下DFS通常是在[递]的过程中维护一个值。<br>+++</p><p><code>LeetCode——</code>二叉树的最大深度（入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</span></p><p><code>LeetCode——</code>二叉树的最小深度（入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/</span></p><p><code>LeetCode——</code>路径总和：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wYXRoLXN1bS9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/path-sum/description/</span></p><p><code>LeetCode——</code>求根节点到叶节点数字之和（向下传递累积值）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zdW0tcm9vdC10by1sZWFmLW51bWJlcnMvZGVzY3JpcHRpb24v">https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/</span></p><p><code>LeetCode——</code>二叉树的右视图（灵活运用DFS）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1yaWdodC1zaWRlLXZpZXcv">https://leetcode.cn/problems/binary-tree-right-side-view/</span></p><p><code>LeetCode——</code>统计二叉树中好节点的数目（向下传递最大值）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9jb3VudC1nb29kLW5vZGVzLWluLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/count-good-nodes-in-binary-tree/</span></p><p><code>LeetCode——</code>二叉树中的伪回文路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9wc2V1ZG8tcGFsaW5kcm9taWMtcGF0aHMtaW4tYS1iaW5hcnktdHJlZS8=">https://leetcode.cn/problems/pseudo-palindromic-paths-in-a-binary-tree/</span> :fire:</p><p>[自底向上DFS]{.rainbow}：</p><p>+++info Summary<br>在[归]的过程中进行计算。<br>入门自底向上DFS很容易，但是掌握好还是稍有难度的。<br>+++</p><p><code>LeetCode——</code>二叉树的最大深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/maximum-depth-of-binary-tree/</span></p><p><code>LeetCode——</code>二叉树的最小深度：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWRlcHRoLW9mLWJpbmFyeS10cmVlLw==">https://leetcode.cn/problems/minimum-depth-of-binary-tree/</span></p><p><code>LeetCode——</code>单值二叉树（掌握自底向上DFS的条件判断）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy91bml2YWx1ZWQtYmluYXJ5LXRyZWUv">https://leetcode.cn/problems/univalued-binary-tree/</span> :fire:</p><p><code>LeetCode——</code>相同的树（先讨论根节点再讨论左右子树）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zYW1lLXRyZWUv">https://leetcode.cn/problems/same-tree/</span></p><p><code>LeetCode——</code>对称二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zeW1tZXRyaWMtdHJlZS8=">https://leetcode.cn/problems/symmetric-tree/</span></p><p><code>LeetCode——</code>翻转等价二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9mbGlwLWVxdWl2YWxlbnQtYmluYXJ5LXRyZWVzLw==">https://leetcode.cn/problems/flip-equivalent-binary-trees/</span> :fire:</p><p><code>LeetCode——</code>找出克隆二叉树中的相同节点（在二叉树中递归寻找目标值）： <span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9maW5kLWEtY29ycmVzcG9uZGluZy1ub2RlLW9mLWEtYmluYXJ5LXRyZWUtaW4tYS1jbG9uZS1vZi10aGF0LXRyZWUv">https://leetcode.cn/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</span></p><p><code>LeetCode——</code>平衡二叉树（利用非法值快速回到递归入口）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iYWxhbmNlZC1iaW5hcnktdHJlZS8=">https://leetcode.cn/problems/balanced-binary-tree/</span></p><p><code>LeetCode——</code>翻转二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9pbnZlcnQtYmluYXJ5LXRyZWUv">https://leetcode.cn/problems/invert-binary-tree/</span> :fire:</p><p><code>LeetCode——</code>合并二叉树：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tZXJnZS10d28tYmluYXJ5LXRyZWVzLw==">https://leetcode.cn/problems/merge-two-binary-trees/</span> :fire:</p><p><strong>自底向上 DFS：删点</strong>：</p><p><code>LeetCode——</code>二叉树剪枝：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wcnVuaW5nLw==">https://leetcode.cn/problems/binary-tree-pruning/</span> :fire:</p><p><code>LeetCode——</code>删除给定值的叶子节点：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbGVhdmVzLXdpdGgtYS1naXZlbi12YWx1ZS8=">https://leetcode.cn/problems/delete-leaves-with-a-given-value/</span> :fire:</p><p><code>LeetCode——</code>删点成林：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kZWxldGUtbm9kZXMtYW5kLXJldHVybi1mb3Jlc3Qv">https://leetcode.cn/problems/delete-nodes-and-return-forest/</span> :fire:</p><p><strong>二叉搜索树</strong>：<br><code>LeetCode——</code>二叉搜索树中的搜索：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9zZWFyY2gtaW4tYS1iaW5hcnktc2VhcmNoLXRyZWUv">https://leetcode.cn/problems/search-in-a-binary-search-tree/</span> :fire:</p><p><strong>回溯</strong>：<br><code>LeetCode——</code>二叉树的所有路径：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9iaW5hcnktdHJlZS1wYXRocy9kZXNjcmlwdGlvbi8=">https://leetcode.cn/problems/binary-tree-paths/description/</span> :fire:</p><h1 id="贪心-blue"><a href="#贪心-blue" class="headerlink" title="[贪心]{.blue}"></a>[贪心]{.blue}</h1><p>[从最大/最小开始贪心]{.rainbow}：</p><p><code>LeetCode——</code>重新分装苹果（排序+贪心，无脑题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hcHBsZS1yZWRpc3RyaWJ1dGlvbi1pbnRvLWJveGVzL2Rlc2NyaXB0aW9uLw==">https://leetcode.cn/problems/apple-redistribution-into-boxes/description/</span></p><p><code>LeetCode——</code>装满石头的背包的最大数量（排序贪心，同无脑题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWJhZ3Mtd2l0aC1mdWxsLWNhcGFjaXR5LW9mLXJvY2tzLw==">https://leetcode.cn/problems/maximum-bags-with-full-capacity-of-rocks/</span></p><p><code>LeetCode——</code>雪糕的最大数量（继续感受无脑贪心）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLWljZS1jcmVhbS1iYXJzLw==">https://leetcode.cn/problems/maximum-ice-cream-bars/</span></p><p><code>LeetCode——</code>K次取反后最大化的数组和（检验排序贪心的真正入门题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWl6ZS1zdW0tb2YtYXJyYXktYWZ0ZXItay1uZWdhdGlvbnMv">https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/</span> :fire:</p><p><code>LeetCode——</code>不同整数的最少数目（哈希+排序贪心）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9sZWFzdC1udW1iZXItb2YtdW5pcXVlLWludGVnZXJzLWFmdGVyLWstcmVtb3ZhbHMv">https://leetcode.cn/problems/least-number-of-unique-integers-after-k-removals/</span></p><p>+++info Summary<br>小技巧——用collections.Counter统计一个序列或可迭代对象每个迭代对象的次数，基本用法：</p><pre><code class="lang-python">from collections import Counter

# 使用字符串初始化Counter
counter = Counter(&quot;mississippi&quot;)
print(counter) # 输出: Counter(&#123;&#39;i&#39;: 4, &#39;s&#39;: 4, &#39;p&#39;: 2, &#39;m&#39;: 1&#125;)

# 使用列表初始化Counter
counter = Counter(list(&quot;mississippi&quot;))
print(counter) # 输出: Counter(&#123;&#39;i&#39;: 4, &#39;s&#39;: 4, &#39;p&#39;: 2, &#39;m&#39;: 1&#125;)
</code></pre><p>+++</p><p><code>LeetCode——</code>非递增顺序的最小子序列（依然是排序贪心）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLXN1YnNlcXVlbmNlLWluLW5vbi1pbmNyZWFzaW5nLW9yZGVyLw==">https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/</span></p><p><code>LeetCode——</code>将数组分成最小总代价的子数组I（纯排序题）：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9kaXZpZGUtYW4tYXJyYXktaW50by1zdWJhcnJheXMtd2l0aC1taW5pbXVtLWNvc3QtaS8=">https://leetcode.cn/problems/divide-an-array-into-subarrays-with-minimum-cost-i/</span></p><p><code>LeetCode——</code>数组大小减半：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9yZWR1Y2UtYXJyYXktc2l6ZS10by10aGUtaGFsZi8=">https://leetcode.cn/problems/reduce-array-size-to-the-half/</span> :fire:</p><p><code>LeetCode——</code>卡车上的最大单元数：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbXVtLXVuaXRzLW9uLWEtdHJ1Y2sv">https://leetcode.cn/problems/maximum-units-on-a-truck/</span> :fire:</p><p><code>LeetCode——</code>幸福值最大化的选择方案：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9tYXhpbWl6ZS1oYXBwaW5lc3Mtb2Ytc2VsZWN0ZWQtY2hpbGRyZW4v">https://leetcode.cn/problems/maximize-happiness-of-selected-children/</span> :fire:</p><p>[单序列配对]{.rainbow}</p><p><code>LeetCode——</code>打折购买糖果的最小开销：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbXVtLWNvc3Qtb2YtYnV5aW5nLWNhbmRpZXMtd2l0aC1kaXNjb3VudC8=">https://leetcode.cn/problems/minimum-cost-of-buying-candies-with-discount/</span> :fire:</p><p><code>LeetCode——</code>数组拆分：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9hcnJheS1wYXJ0aXRpb24v">https://leetcode.cn/problems/array-partition/</span> :fire:</p><p><code>LeetCode——</code>数组中最大数对和的最小值：<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS5jbi9wcm9ibGVtcy9taW5pbWl6ZS1tYXhpbXVtLXBhaXItc3VtLWluLWFycmF5Lw==">https://leetcode.cn/problems/minimize-maximum-pair-sum-in-array/</span> :fire:</p></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-06-18 23:39:02" itemprop="dateModified" datetime="2025-06-18T23:39:02+08:00">2025-06-18</time> </span><span id="cs/ACM算法题单/" class="item leancloud_visitors" data-flag-title="ACM算法题单" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.jpg" alt="Runhua Deng 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="Runhua Deng alipay"><p>alipay</p></div><div><img data-src="/images/paypal.png" alt="Runhua Deng paypal"><p>paypal</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Runhua Deng <i class="ic i-at"><em>@</em></i>枯萎的花将在另一彼岸悄然绽放</li><li class="link"><strong>本文链接：</strong> <a href="https://yunhdan.github.io/cs/ACM%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%95/" title="ACM算法题单">https://yunhdan.github.io/cs/ACM算法题单/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/cs/Javascript%E7%9F%A5%E8%AF%86%E6%A0%91/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2025&#x2F;05&#x2F;18&#x2F;whNHCopuOyMl9Ta.jpg" title="Javascript知识树"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机</span><h3>Javascript知识树</h3></a></div><div class="item right"><a href="/cs/Pip%E3%80%81Conda%E3%80%81github%E9%95%9C%E5%83%8F/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;s2.loli.net&#x2F;2024&#x2F;12&#x2F;07&#x2F;jfKdoJw71Lg25uG.jpg" title="Pip、Conda、Github镜像"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> 计算机</span><h3>Pip、Conda、Github镜像</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-blue"><span class="toc-number">1.</span> <span class="toc-text">[哈希表]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88-blue"><span class="toc-number">2.</span> <span class="toc-text">[双指针]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-blue"><span class="toc-number">3.</span> <span class="toc-text">[滑动窗口]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95-blue"><span class="toc-number">4.</span> <span class="toc-text">[二分算法]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88-blue"><span class="toc-number">5.</span> <span class="toc-text">[栈]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE-blue"><span class="toc-number">6.</span> <span class="toc-text">[枚举]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-blue"><span class="toc-number">7.</span> <span class="toc-text">[前缀和]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E6%A0%BC%E5%9B%BE-blue"><span class="toc-number">8.</span> <span class="toc-text">[网格图]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-blue"><span class="toc-number">9.</span> <span class="toc-text">[二叉树]{.blue}</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-blue"><span class="toc-number">10.</span> <span class="toc-text">[贪心]{.blue}</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/cs/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%90%86%E8%AE%BA/" rel="bookmark" title="编译原理理论">编译原理理论</a></li><li><a href="/cs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA1/" rel="bookmark" title="数据库理论1">数据库理论1</a></li><li><a href="/cs/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA2/" rel="bookmark" title="数据库理论2">数据库理论2</a></li><li><a href="/cs/Javascript%E7%9F%A5%E8%AF%86%E6%A0%91/" rel="bookmark" title="Javascript知识树">Javascript知识树</a></li><li class="active"><a href="/cs/ACM%E7%AE%97%E6%B3%95%E9%A2%98%E5%8D%95/" rel="bookmark" title="ACM算法题单">ACM算法题单</a></li><li><a href="/cs/Pip%E3%80%81Conda%E3%80%81github%E9%95%9C%E5%83%8F/" rel="bookmark" title="Pip、Conda、Github镜像">Pip、Conda、Github镜像</a></li><li><a href="/cs/Vue/" rel="bookmark" title="Vue">Vue</a></li><li><a href="/cs/Flask/" rel="bookmark" title="Flask">Flask</a></li><li><a href="/cs/Pytorch/" rel="bookmark" title="Pytorch">Pytorch</a></li><li><a href="/cs/Conda%E3%80%81Pip%E3%80%81Cuda/" rel="bookmark" title="Conda、Pip、Cuda">Conda、Pip、Cuda</a></li><li><a href="/cs/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97/" rel="bookmark" title="边缘计算">边缘计算</a></li><li><a href="/cs/Springboot%E3%80%81Mybatis/" rel="bookmark" title="Springboot、Mybatis">Springboot、Mybatis</a></li><li><a href="/cs/Linux/" rel="bookmark" title="Linux">Linux</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Runhua Deng" data-src="/images/me.jpg"><p class="name" itemprop="name">Runhua Deng</p><div class="description" itemprop="description">计算机视觉 & 图像恢复</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">45</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">7</span> <span class="name">分类</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL1l1bkhEYW4=" title="https:&#x2F;&#x2F;github.com&#x2F;YunHDan"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTIxMjYzMjE4OTI=" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;2126321892"><i class="ic i-cloud-music"></i></span> <a href="/alex2312666252@gmail.com" title="alex2312666252@gmail.com" class="item email"><i class="ic i-envelope"></i></a> <span class="exturl item csdn" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzczNTk5NzM4P3NwbT0xMDAwLjIxMTUuMzAwMS41MzQz" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;m0_73599738?spm&#x3D;1000.2115.3001.5343"><i class="ic i-link"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a><ul class="submenu"><li class="item"><a href="/about/me/" rel="section"><i class="ic i-file"></i>简历</a></li><li class="item"><a href="/about/learn_me/" rel="section"><i class="ic i-smile"></i>了解我</a></li></ul></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友達</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/cs/Javascript%E7%9F%A5%E8%AF%86%E6%A0%91/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/cs/Pip%E3%80%81Conda%E3%80%81github%E9%95%9C%E5%83%8F/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/book/" title="分类于 读书">读书</a></div><span><a href="/book/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/" title="《被讨厌的勇气：“自我启发之父”阿德勒的哲学课》">《被讨厌的勇气：“自我启发之父”阿德勒的哲学课》</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/cs/" title="分类于 计算机">计算机</a></div><span><a href="/cs/Linux/" title="Linux">Linux</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 人工智能">人工智能</a></div><span><a href="/ai/Deep-Learning-Experiment-Tricks/" title="Deep Learning Experiment Tricks">Deep Learning Experiment Tricks</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/baoyan/" title="分类于 保研">保研</a></div><span><a href="/baoyan/%E4%BF%9D%E7%A0%94%E4%BF%A1%E6%81%AF%E6%B1%87%E6%80%BB/" title="保研信息汇总">保研信息汇总</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/research/" title="分类于 学术">学术</a></div><span><a href="/research/Retinexformer%E8%AE%BA%E6%96%87%E8%AF%A6%E8%A7%A3/" title="Retinexformer论文详解">Retinexformer论文详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/ai/" title="分类于 人工智能">人工智能</a></div><span><a href="/ai/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" title="深度学习理论">深度学习理论</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/project/" title="分类于 项目与实践">项目与实践</a></div><span><a href="/project/%E5%9F%BA%E4%BA%8ECLIP%E7%9A%84%E5%9B%BE%E5%83%8F%E7%89%A9%E4%BD%93%E8%BE%A8%E5%88%AB/" title="基于CLIP的图像物体辨别">基于CLIP的图像物体辨别</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/other/" title="分类于 琐碎">琐碎</a></div><span><a href="/other/My%20%E4%BA%8C%E6%AC%A1%E5%85%83/" title="My 二次元">My 二次元</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/research/" title="分类于 学术">学术</a></div><span><a href="/research/Low%20Level%20Vision%E8%AE%BA%E6%96%87%E7%B2%BE%E7%82%BC/" title="Low Level Vision论文精炼">Low Level Vision论文精炼</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/baoyan/" title="分类于 保研">保研</a></div><span><a href="/baoyan/Low-level-Vision-Group/" title="Low-level-Vision-Group">Low-level-Vision-Group</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Runhua Deng @ Runfar's Zone</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">196k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">2:58</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"cs/ACM算法题单/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({log:!1,pluginJsPath:"lib/",pluginModelPath:"assets/",pluginRootPath:"live2dw/",tagMode:!1})</script></body></html><!-- rebuild by hrmmi -->